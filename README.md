#1. Об архитектуре
Архитектура - это набор принципов и правил, которые помогают организовать и структурировать программный код.
Архитектура необходима для создания программного продукта, программного комплекса и системного программного продукта.
Архитектура становится полезной, когда объем кода превышает 5000 строк. Она особенно важна для создания систем с сотнями тысяч строк кода.
Архитектура может быть полезна для смены профессиональной траектории, например, с Data Scientist на backend developer.
Архитектура помогает организовать и структурировать код, что особенно важно для больших систем.
В академическом сообществе под архитектурой системы понимают формальные описания, позволяющие доказывать ее свойства.
В продакшене архитектура понимается как свод знаний о системе, который может меняться и эволюционировать.
Архитектура может быть статической или динамической, с разными уровнями детализации. Она позволяет сократить затраты на кодирование и упростить жизнь разработчиков.
Архитектура является средством для управления проектом и оценки стоимости разработки. 
Архитектор - это специально выделенный человек (или группа людей) отвечающий за: разаработку и описание архитектуры системы, доведение её до всех заинтересованных лиц (заказчик,разработчик), контроль реализации архитектуры, поддержание её актуального состояния по ходу разработки и сопровождения.
Трудовые функции архитектора(по профстандарту): выявление и согласование требований к программной сиситеме с точки зрения архитектуры, выбор и моделирование архитектурного решения для реализации программной системы, разработка разделов по архитектуре проектных и эксплуатационных документов программной системы, контроль реализации и испытаний программной системы с точки зрения архитектуры, сопровождение эксплуатации программной сиситемы с точки зрения архитектуры. 
Выбор архитектурного стиля субъективен и зависит от вкуса и интуиции. Разные архитектурные стили могут подходить для разных задач, и наоборот, один и тот же стиль может подходить для многих задач.
Архитектурные стили: слоистая архитектура(ОС), объектно ориентированная архитектура, каналы и фильтры.
Архитектурные виды: статическая структура, динамическая структура.
Архитектурные стили и виды могут быть использованы для моделирования различных систем, включая социографы, сетевые протоколы, операционные системы, математические расчеты, визуальные языки и анализ данных.  Архитектура относится ко всему жизненному циклу системы, начиная с появления требований и заканчивая поддержкой системы. Архитектура используется на этапе проектирования, анализа, реализации, тестирования и поддержки системы. Диаграммы случаев использования могут быть использованы для моделирования требований к системе.
Бизнес-ограничения и технические ограничения играют важную роль в архитектуре, так как они могут ограничивать возможности использования определенных технологий. Например, если для разработки системы используется только определенный язык программирования, то архитектура будет зависеть от этого ограничения. Если сроки разработки ограничены, то архитектура также может быть изменена, чтобы соответствовать этим срокам.
Разные архитектурные стили и методологии проектирования и программирования могут быть использованы для разных функциональных требований.
Архитектура должна быть описана в документации и должна быть единообразной для всей системы.

2. Декомпозиция, объектно-ориентированное проектирование
Сложность бывает двух типов: существенная и случайная. Существенная сложность присуща решаемой проблеме и не может быть полностью уничтожена. Случайная сложность - сложность, привнесённая способом решения проблемы
Свойства сложных систем: иерархичность - свойство системы состоять из иерархии подсистем или компонентов; наличие относительно небольшого количества видов компонентов, экземпляры которых сложно связаны друг с другом; сложная система, как правило является результатом эвалюции простой системы; сложность вполне может превосходить человеческие интеллектуальные возможности.
Восходящее проектирование: разбиение задачи на подзадачи и реализация каждой подзадачи отдельно. Восходящее проектирование позволяет легко тестировать систему еще до ее разработки целиком.
Модульность - это принцип, который предполагает разделение программы на отдельные модули, каждый из которых выполняет свою задачу. Модули могут быть реализованы в разных языках программирования, но в объектно-ориентированных языках они обычно представляют собой компоненты или классы. Каждый модуль должен знать, что он делает, и иметь минимальный внешний интерфейс. Модули должны иметь единственную ответственность и не иметь побочных эффектов. Модули не должны зависеть друг от друга и должны скрывать свое внутреннее состояние.
Модульность позволяет создавать сложные системы, разбивая сложные задачи на более простые.Разделение на модули и описание способов взаимодействия между ними позволяет расплести разработку, позволяя отдельным командам или разработчикам работать над своими модулями независимо.
Метрики модульной архитектуры: Сопряжение - это мера того, насколько сильно взаимодействуют разные модули в программе. Связанность - это степень, в которой задачи модуля связаны друг с другом.
Объекты - это маленькие компьютеры, которые имеют состояние и операции, которые можно выполнять. Объекты имеют состояние, поведение и идентичность. Идентичность - это способ сказать, что два объекта одинаковы или разные. Варианты - это набор логических условий, которые должны быть выполнены для объекта. Варианты помогают избежать большого количества проверок в реализации методов объектов.
Объекты отличаются от структур с методами, так как они не общаются напрямую и реализуют полиморфизм. Объекты являются экземплярами класса, но классы не являются необходимым атрибутом объектно-ориентированного программирования.
Абстракция выделяет существенные характеристики объекта, отличающие его от остальных объектов с точки зрения наблюдателя. Инкапсуляция разделяет интерфейс абстракции и её реализацию. Инкапсуляция защищает инварианты абстракции.
Наследование используется в предметной области, где есть классификация, например, в биологическом мире. Наследование также применяется в компиляторах и грамматиках, где иерархия является основой для построения синтаксического дерева. В современных языках наследование обычно используется для переиспользования кода, а не для исследования.
Сложные структуры данных и алгоритмы могут быть спрятаны за простым интерфейсом для упрощения понимания системы.
Принцип единственности ответственности: каждый объект должен иметь одну обязанность, которая полностью на него возложена. Принцип разделения интерфейса и реализации: интерфейс должен быть простым и понятным, а реализация скрыта за интерфейсом.
Принцип открытости-закрытости говорит о том, что программы должны быть открыты для расширения, но закрыты для изменения. Для расширения используются точки расширения, которые могут быть определены как абстрактные классы с наследниками. Принцип разделения интерфейсов говорит о том, что клиенты не должны зависеть от методов, которые они не используют. Принцип инверсии зависимостей говорит о том, что модули верхних уровней не должны зависеть от модулей нижних уровней, а должны зависеть от абстракций.
Закон Деметры запрещает объектам обращаться к полям и методам других объектов, если они не имеют к ним прямого отношения. Это помогает избежать проблем при изменении реализации объектов и обеспечивает абстракцию.
Медиатор - это объект, обеспечивающий взаимодействие между группой объектов.
Ответственность класса должна быть обозрима и понятна для человека, который его использует. В реальных библиотеках могут быть классы с десятками методов, но это не обязательно означает, что они не выполняют свою единственную ответственность.

3. Моделирование. UML
Типы моделей: Визуальные модели могут быть неформальными (картинки без формального синтаксиса) или формальными (полноценные языки программирования). Архитектурные модели фиксируют архитектурные решения системы и могут быть представлены в виде кода или визуальных моделей.
Моделирование помогает коммуникации между разработчиками, облегчает понимание архитектуры системы и документации. Модели могут быть использованы для документирования и общения с заказчиком.  Модели могут быть естественными языками, визуальными языками или формальными нотациями. Естественные языки используются для первичного анализа предметной области и уточнения архитектуры.
Неформальные графические модели, такие как картинки, могут быть более компактными и восприниматься быстрее, чем текст. Однако, они не всегда полезны для автоматической обработки и могут быть неоднозначными для понимания.
Формальные графические модели, такие как UML, имеют стандартизированный синтаксис и могут быть использованы для описания архитектуры и поведения системы. Однако, они могут быть сложными для понимания и расширения, и не всегда обеспечивают ассистентность модели.
Визуальные модели остаются более популярными из-за их простоты и наглядности.
Визуальные модели могут быть использованы для разных целей, включая объяснение, что нужно сделать, и для тестирования. Модели всегда должны быть проще, чем система, чтобы быть полезными. Графические исходники не являются моделями, так как они содержат много информации, которая может быть лучше структурирована, но не упрощает анализ.
Предметно-ориентированные языки заточены под конкретную задачу, но не могут решать другие задачи.
Диаграмма классов - самая популярная диаграмма, но есть и другие, такие как диаграмма обзора взаимодействия и диаграмма классов стандартной аннотации. Диаграммы объектов показывают структуру системы во время выполнения, но относятся к структурным диаграммам.  Диаграммы компонентов являются полезными, так как они редко меняются и могут быть использованы для анализа системы. Они имеют простой синтаксис и могут быть использованы для определения архитектуры системы.

4. Моделирование и анализ.
Требования необходимы для понимания и согласования видения системы с пользователями и заказчиками.Требования также используются для планирования проекта и определения границ системы.
Диаграмма случаев использования является основой метода случаев использования. Диаграмма описывает требования к системе и может быть использована для проектирования статических моделей. На практике, диаграммы использования редко используются, предпочитая более простые и понятные варианты. Контекстные диаграммы описывают внешние факторы, влияющие на систему, без декомпозиции. Используются для анализа бизнес-процессов и программного обеспечения. Диаграмма характеристик декомпозирует требования в виде дерева, где в корне находится система, а в узлах - элементарные или составные требования. Диаграмма характеристик полезна для анализа требований в больших проектах, где есть несколько программных продуктов, разделяющих общую кодовую базу или разные версии одного продукта. Диаграмма требований используется для анализа требований к системе. Требования уточняются и связываются с реализацией системы. Диаграмма активности используется для моделирования бизнес-процессов, например, для описания алгоритма или сценария использования. Диаграмма активности может быть вложенной и содержать условные блоки, решения и блоки слияния. Диаграмма активности работает на основе сетей Петри.
Сети Петри - это набор мест и переходов, где места могут содержать токены исполнения один или ноль, а переходы срабатывают, если во всех входящих местах есть токены исполнения.
Диаграмма активностей - это визуальное представление бизнес-процесса, где каждый блок представляет собой оператор, а переходы - исполнение операторов.  Диаграмма активностей позволяет моделировать параллельные процессы.
Диаграмма развертывания используется на начальных фазах жизненного цикла для понимания того, какие компоненты системы нужно разделить на физическом оборудовании. Диаграмма сущность-связь используется для описания модели данных или концептуальной модели предметной области. В отличие от диаграммы классов, диаграмма сущность-связь не умеет наследования и отношения многие ко многим, но может быстро смоделировать данные в информационных системах.Альтернативой диаграммам сущность-связь могут быть диаграммы объектно-реляционного моделирования (ORM)
5. Моделирование поведения.
Генерация таблиц состояний может быть автоматизирована, например, для лексического анализа с использованием генераторов синтаксических анализаторов. В этом случае, грамматика на высокоуровневом языке автоматически генерирует таблицу состояний, которая разбирается с помощью регулярных выражений.
Паттерн состояния предполагает создание класса для каждого состояния, реализующего интерфейс с методами для всех возможных событий. Если состояние не может перейти по определенному событию, переход остается пустым. Контроллер запоминает текущее состояние и переключает его при выполнении действия по переходу. Хотя паттерн состояния удобен для ручной реализации, он может быть неудобен для автоматической генерации из-за большого количества дополнительного кода.
Диаграммы последовательности используются для визуализации хитрых взаимодействий и отладки. Применяются в телекоммуникационных протоколах, но также полезны для проектирования обычных систем.
Фреймы - механизм для визуализации нетривиальных алгоритмов на диаграммах последовательностей.
Диаграммы кооперации используются для раскрытия порядка взаимодействия между объектами. Они не отображают передачу информации между объектами, но показывают, как объекты связаны во время исполнения.
Временные диаграммы используются для моделирования систем реального времени.
 Они позволяют визуализировать временные ограничения и взаимосвязи между участниками взаимодействия.
Диаграммы обзора взаимодействия объединяют диаграммы активности и последовательности для визуализации сложных бизнес-процессов. Они могут быть полезны для визуализации логической ветвления и циклов в алгоритмах.
Диаграмма потока данных показывает поток данных в системе, включая процессы, внешние сущности и места временного хранения данных. Она может быть полезна в системах, занимающихся обработкой данных.
Диаграмма компонентов и классов используется для анализа и проектирования архитектуры системы. Она раскрывает каждый блок в системе и позволяет визуализировать требования к системе.
Петри-сети - это тройка из множества мест, множества переходов и функций потока, которые отображают места и переходы на натуральные числа. Семантика сетей определяется понятием срабатывания, которое вычисляет маркировку по функции потока. Петри-сети могут моделировать не детерминизм, позволяя выбирать случайный переход и его срабатывание или порождать несколько сетей петри, соответствующих сработавшим переходам. Сети Петри представляют собой сеть переходов, каждый из которых может срабатывать и перемещать токины между местами. Сети Петри могут быть проанализированы на предмет поведенческих и структурных свойств, таких как достижимость, ограниченность, безопасность, живость, реверсабельность и домашнее состояние. Эти свойства могут быть использованы для проверки правильности работы системы и предотвращения переполнения буфера или других проблем.
Для анализа сетей Петри используются два основных подхода: построение линейных уравнений и анализ дерева состояний.

6.Структурные шаблоны
Компоновщик решает задачу представления иерархии объектов и возможности единообразной обработки этой иерархии. Компоновщик используется повсеместно, но имеет проблемы с объектно-ориентированным программированием.
Операции работы с потомками могут быть реализованы в компоненте или в листе, но в обоих случаях могут быть проблемы.
Списки потомков могут быть сложной структурой данных, и их реализация может быть в компоненте или листе.
Компоновка позволяет экономить память и время выполнения, но требует аккуратного обращения с порядком потомков.
Моноглифы - это базовый класс, который обрамляет сына, добавляя ему новую функциональность.
Моноглифы позволяют добавлять элементы оформления к фрагментам текста, изменяя их во время выполнения. Идея прозрачного обрамления позволяет использовать элементы пользовательского интерфейса внутри физической структуры документа.
Декоратор позволяет добавить функциональность к существующему объекту, не затрагивая его внешний вид. Паттерн прокси и адаптер могут выполнять те же функции, что и декоратор, но с некоторыми ограничениями. Паттерн стратегия может быть удобнее, но требует модификации декорируемого объекта.
Пользователь может выбирать разные алгоритмы форматирования для разных ситуаций. Идея обобщается до паттерна стратегия, где алгоритм форматирования может быть определен в потомках.
Стратегия - это класс, который реализует абстрактный интерфейс и может быть использован в контексте для выполнения определенных действий. Стратегия может быть реализована в виде класса или интерфейса, и может быть изменена во время выполнения.  Стратегия может быть использована для инкапсуляции сложного алгоритма, для переключения между несколькими вариантами алгоритмов, для работы с данными, которые не должны быть известны контексту. Стратегия может принимать данные для работы в качестве параметров или передавать контекст в качестве аргумента. Стратегия может быть параметризована с помощью шаблона, что позволяет избежать использования абстрактного класса или виртуальных методов. Адаптеры позволяют использовать сторонние библиотеки в графическом редакторе, реализуя их интерфейс. Адаптеры могут быть двух типов: адаптер объекта и адаптер класса. Адаптеры класса могут быть полезны для реализации правил наследования. Прокси могут быть использованы для загрузки изображений из файла только при необходимости. Прокси могут быть полезны для распределенных приложений, где запросы отправляются на другую машину и обрабатываются там. Прокси также могут использоваться для управления доступом и реализации блокировок.
Фасад - это способ предоставить простой интерфейс к сложной подсистеме, возможно, инкапсулируя ее. Фасад может быть абстрактным классом, предоставляющим интерфейс и фабрику для конкретной реализации. Фасад гарантирует уровневую архитектуру, так как единственный публичный класс - это фасад, и все взаимодействие происходит через него.

7. Порождающие шаблоны.
Мост отделяет абстракцию от реализации, позволяя абстракции взаимодействовать с реализацией. Пример: система для программирования роботов, где интерпретатор работает с абстрактной моделью робота, а модель робота предоставляет реализацию для интерпретации.
Мост состоит из двух иерархий: абстракция и реализация. Абстракция определяет логический интерфейс для внешнего мира, а реализация предоставляет конкретные операции. Реализация может быть в отношении агрегации или композиции с абстракцией.
Прикомпилируемые заголовки могут быть полезны для ускорения сборки системы, но они могут быть ненадежными и вызывать проблемы при смене набора инструментов.
Фабричный метод может быть реализован с помощью статического метода или виртуального метода с возможностью переопределения в конкретных типах. Фабричный метод позволяет разделить код на содержательную часть и часть, относящуюся к конкретной реализации, и использовать один класс для создания объектов. Он позволяет создавать объекты, используя абстрактный класс или интерфейс. Он может быть чисто виртуальным, что позволяет переопределить его в подклассах. Фабричные методы могут быть параметризованными, что позволяет выбирать конкретный тип продукта на основе переданного параметра.
Абстрактная фабрика - это класс, который содержит только фабричные методы для создания объектов. Абстрактная фабрика может быть использована для создания объектов, которые имеют разные реализации, но должны быть связаны с одним интерфейсом. Абстрактная фабрика может быть использована для инкапсуляции реализации объектов от клиента.
Паттерн Одиночка гарантирует, что у класса есть только один экземпляр. Он предостовляет глобальный доступ к этому экземпляру. Одиночка усложняет тестирование и добавляет неочевидные зависимости по данным.
(volatile позволяет потокам увидеть изменения в том порядке в котором они изменялись.)
Паттерн ленивая инициализация это некоторое упращение одиночки. Его действие не выполняется до тех пор, пока не нужен его результат. Используется повсеместно, для ускарения запуска и экономии на редких вычислениях.
Паттерн пул объектов (более гибкая структура). Поток уничтожается, когда операция завершилась. Создание и остановка потоков - долгие операции, при этом каждый поток требует системных ресурсов.
Пул объектов применяется, когда объекты создавать сложно, но каджый объект нужен лишь ненадолго. В случае с пулами объектов, проблемы с многопоточностью могут возникать из-за необходимости следить за временем жизни объектов и их распределением.
Реализация клонирования может быть сложной, особенно если нужно клонировать сложные объекты, такие как деревья. Глубокое копирование предпочтительнее, но может быть сложно реализовать из-за круговых ссылок.

8. Поведенческие шаблоны
Паттерн строитель позволяет создавать объекты, используя последовательность этапов.
В Java и C# паттерн "Наблюдатель" реализуется через анонимные классы и ключевые слова "event" и "subscribe". В C# можно переопределить методы "subscribe" и "unsubscribe" для произвольного кода.
Паттерн "Наблюдатель" может привести к утечке памяти и трудностям в отладке. Важно быть аккуратным при наследовании и управлении идентификациями. Рекомендуется документировать, кто и когда отправляет идентификацию.
Пул-схема: обсервер запрашивает у сабжекта информацию о произошедших изменениях, сабжек передает информацию обсерверу. Пуш-схема: сабжек сразу передает информацию обсерверу, который обновляет себя.
Комбинированная схема: сабжек сообщает об изменениях, обсервер запрашивает информацию о них. Паттерн посредник позволяет бороться с большим количеством связей между объектами, например, в случае выбора шрифтов в текстовом редакторе.
Идея паттерна команда заключается в разделении инициации запроса и его исполнения.
Паттерн команды. Команды могут содержать бизнес-логику, содержать модель данных или быть частью доменной модели. Команды могут быть очень умными или очень глупыми, в зависимости от их реализации. Команды могут быть реализованы с помощью контроллера, который принимает команды и кладет их в стек для последующей отмены. Команды могут быть искусственными, которые добавляются другими компонентами системы для реализации сложного поведения.
Паттерн "Цепочка ответственности" позволяет создавать цепочки из объектов, которые могут обрабатывать определенные события. Пример использования: распространение событий внутри оконных интерфейсов. Проблема паттерна "Цепочка ответственности" заключается в том, что получение запроса не гарантируется, и он может пробежать всю цепочку и вывалиться наружу. Решение: реализация паттерна, где запрос отправляется нескольким объектам одновременно, что позволяет ослабить связанность и меньше думать при программировании.
Паттерн состояния позволяет динамически менять поведение объекта в зависимости от его текущего состояния.
Паттерн посетитель используется для реализации синтаксического анализатора, который парсит исходный код и строит синтаксическое дерево. В примере обсуждаются различные операции, которые могут быть выполнены над синтаксическим деревом, и как они могут быть реализованы в отдельном классе
В абстрактном базовом классе объявляется метод accept, который принимает объект-визитор. В каждом из наследуемых классов метод accept реализуется в одну строчку, вызывая метод visit, соответствующий данному конкретному классу.
В паттерне визитор объектная структура дергает визитор, визитор дергает конкретный элемент, а конкретный элемент дергает визитор. Добавление новых классов в объектную структуру может быть сложным. Визитор может управлять обходом, но может быть нарушена инкапсуляция. Визитор может иметь свое состояние и накапливать его постепенно. Перегрузка методов визитора не рекомендуется, так как сложно понять, какой именно метод вызывается.

9. Антипаттерны.
Причины появления антипаттернов: спешка, отсутствие времени на рефакторинг, нежелание изучать хорошие решения, лень, жадность, архитектурная жадность, неведение, гордыня.
Последствия использования антипаттернов: трата времени на исправление ошибок, снижение качества кода, увеличение стоимости разработки, потеря времени на сопровождение.
Круговая зависимость возникает, когда несколько компонентов зависят друг от друга по кругу, что затрудняет понимание системы и может привести к ошибкам. Последовательная связанность - это ситуация, когда необходимо вызывать методы класса в определенном порядке, что может привести к проблемам при изменении порядка вызовов. Использование инверсии зависимости, слоев архитектуры и паттернов, таких как наблюдатель, помогают избежать проблем с кругами и последовательной связанностью.
Антипаттерны могут быть полезными в определенных ситуациях, но важно не злоупотреблять ими.
Использование крутящихся ожиданий может быть приемлемым для небольших систем, но в большинстве случаев лучше использовать механизмы синхронизации, такие как семафоры.
Медиатор - это паттерн, который помогает координировать непрямые зависимости, но может стать антипаттерном, если его использовать слишком много. В качестве примера антипаттерна можно привести стандартные типы Java, которые имеют множество методов, которые могут быть не нужны в большинстве случаев.
Поток лавы - это ситуация, когда разработчики активно пробуют разные варианты, реализуют прототипы, но в итоге все это застывает в коде и не удаляется. Это может привести к появлению временных решений, которые могут быть вредными и не всегда необходимыми. Для борьбы с потоком лавы можно использовать прототипирование и проектирование, а также контроль версий с метками. Если временное решение все же появилось, его можно вылечить, но это может быть сложным процессом. В некоторых случаях, лучше переписать систему с нуля, чем пытаться исправить ошибки в старой системе.

10. Архитектурные стили
Архитектурные стили - набор решений, которые 1)применимы в выбранном контексте разработки; 2)задают ограничения на принимаемые архитектурные решения, специфичные для определённых систем в этом контексте; 3)приводят к желаемым положительным качествам получаемой системы
Трехзвенная архитектура: клиент, бизнес-логика, база данных.
Модуль-контроллер: разделение между видом, контроллером и моделью для обработки пользовательского ввода и хранения данных.
Модуль-вью: при просмотре отображается информация для пользователя, контроллер обрабатывает дополнительные входы, а модель сохраняет данные и бизнес-логику.
Модуль-контроллер: используется в разработке веб-приложений, где вью и контроллер взаимодействуют через модель.
Модуль-вью-модуль: используется в разработке графических клиентов и мобильных приложений, где вью и модель взаимодействуют через вью-модуль.
В робототехнике и других приложениях, которые собирают данные и выдают результаты их обработки, используется архитектурный шаблон, описывающий жизненный цикл приложения. Архитектурные стили в программировании, как и в архитектуре зданий, выбираются на основе предпочтений, а не насущной необходимости.
Архитектурные стили могут быть привязаны к конкретному окружению, в котором работает система.
Архитектурные стили могут использоваться для разных подсистем и могут быть реализованы в разных стилях.
Архитектурные стили предполагают использование кода и фреймворков, которые реализуют определенный стиль.
Архитектурные стили могут включать в себя методы анализа и визуализации, которые могут быть специфичными для данного стиля.
В слоистом стиле каждый уровень знает только о предыдущем уровне ниже.
Строгий стиль гарантирует, что изменения в реализации одного уровня затрагивают только непосредственно зависимый уровень.
В гексагональной архитектуре, в отличие от классических подходов, уровень предметной области находится на самом нижнем уровне.
Система собирается из компонентов, каждый из которых состоит из моделей предметной области и классов, реализующих ее, а также портов и адаптеров, позволяющих этой предметной области взаимодействовать с внешним миром.
Название «шестиугольная архитектура» связано с тем, что ее удобно рисовать шестиугольниками, и она состоит из компонентов, каждый из которых состоит из моделей предметной области и классов, реализующих ее.
Адаптеры конвертируют запрос извне во внутреннее представление, удобное для работы доменной модели, и отвечают за валидацию и верификацию данных.
Модель предметной области может использовать данные, хранящиеся в базе данных, с помощью адаптера базы данных.
Гексагональная архитектура позволяет полностью изолировать механизмы доставки и вспомогательные механизмы, что делает ее популярной.
Гексагональная архитектура обеспечивает удобство тестирования, например, управление интерфейсами и адаптерами, что позволяет тестировать систему независимо и без проблем.
Луковая архитектура уточняет уровень бизнес-логики в гексагональной архитектуре, разделяя систему на слои со строгими топологическими ограничениями.
В центре системы находится модель предметной области, над которой контролируются доменные сервисы, приложения и инфраструктурные объекты.
В чистой архитектуре поток управления более продуман и понятен.В ней есть границы системы, внешний мир и машинное обеспечение для взаимодействия с внешним миром.Внутри системы только корректная информация, прошедшая верификация, валидация и конвертация.
В архитектуре каналов и фильтров вся система строится из фильтров, связанных с публикациями, которые преобразуют данные.Фильтры не имеют права знать друг о друге, но могут декларировать порты для входа каналов. Фильтры могут быть по-разному собраны и легко заменяются.
Алгоритмы Маркова - это попытка формализации процесса вычисления, который конкурирует с машинами Тьюринга и лямбда-исчислением. Алгоритмы Маркова устроены как грамматики, где есть набор продукций над строками, которые применяются ко входной строке. Это позволяет записывать произвольные вычисления.
Событийные стили стремятся отвязать отправителя от сообщения и получателя, используя противоположные методы. Это позволяет легко переиспользовать компоненты и конфигурировать систему во время выполнения.
Шина передает сообщения между компонентами, которые могут быть умными или тупыми. В большинстве случаев за столом тупые, они просто пишут сообщения всем подписчикам.
Сорсинг позволяет компонентам не иметь собственного состояния, а строить его на основе сообщений. Это позволяет избежать синхронизации и поддержания общего распределенного состояния.

11. Предметно-ориентированное проектирование
Предметно-ориентированное проектирование (DDD) - методология, которая отвечает на вопрос "как создавать архитектуру системы".
DDD не предполагает написание архитектуры конкретного приложения, а анализирует предметную область, строит ее модель и выражает ее в коде. Цель DDD - создать приложение, которое существенно лучше, чем ожидается, а не просто хорошее приложение.
DDD помогает разобраться в предметной области, понять, что на самом деле нужно заказчику. DDD позволяет избежать двусмысленностей и тестировать модель, общаясь друг с другом на едином языке.
Диаграммы классов и объектов используются для анализа и классификации. Диаграммы объектов полезны для обсуждения с экспертом и наведения классификации.
Моделирование с использованием естественного языка позволяет переиспользовать многотысячелетний опыт общения и объяснения предметной области. Моделирование помогает объяснить архитектуру проекта и предметную область.
Начиная с определенного уровня карьеры, программисты должны выбрать специализацию в рамках предметной области. Например, если вы знаете нейрохирургию, вы можете быть ценным специалистом для компаний, разрабатывающих софт для нейрохирургии.
Четырехуровневая архитектура
Предметная область - это ценность, которая делает приложение полезным для конечного пользователя.
Предлагается типовая четырехуровневая архитектура для всех приложений, сделанных по методологии DDD.
Интерфейс - это уровень, который общается с пользователем и получает от него ввод.
Операционный уровень - это уровень, который реализует взаимодействие с пользователем в рамках конкретного приложения.
Уровень предметной области - это библиотека классов, которая может быть переиспользована и не знает о конкретных приложениях.
Инфраструктурный уровень - это уровень, на котором находятся используемые программы и библиотеки, такие как базы данных и сети.• Модель предметной области должна быть отделена от всего остального, чтобы ее можно было переиспользовать.
Классы модели должны уметь делать только то, для чего они предназначены, и ничего больше.
Бизнес- регламенты должны выполняться на уровне модели предметной области. 
Уровень предметной области - это не просто классы, а содержательная логика работы бизнес-процесса.
Объекты и сущности в объектно-ориентированном программировании имеют разные значения и свойства.
Объекты полностью определяют свои атрибуты, а сущности могут быть разделяемыми и иметь мутабельные свойства.
В примере с кинотеатром, места в зале могут быть сущностями, а билеты на сеанс - объектами значений.
Агрегаты - это изолированные куски модели, имеющие корень и границу.
Корень агрегата глобально идентичен и может быть использован для идентификации, а граница содержит только локально идентичные объекты. Агрегаты обеспечивают инварианты и правила взаимодействия с внешним миром через корень.
Фабрики создают и объекты, и агрегаты, могут быть сложными и использовать различные паттерны проектирования.
Хранилища предоставляют доступ к данным из базы данных или других источников, не раскрывая подробностей о них.
Хранилища могут быть типизированными и использоваться для доступа к содержимому агрегатов.
В примере с системой грузоперевозок, хранилища используются для предоставления информации о местонахождении груза, оформления заказов на доставку и выставления счетов. В модели определены агрегаты, такие как груз и история доставки, и репозитории для работы с этими агрегатами.
Репозитории позволяют искать объекты в приложении, например, кастомеры или грузы.
Модель также включает в себя разделение объектов между агрегатами, что позволяет использовать их в разных приложениях без необходимости их повторного создания.
Паттерн спецификация позволяет инкапсулировать ограничения в отдельный объект, который может быть использован для проверки и корректировки результатов.
Паттерн может быть применен для выборки объектов из репозитории и для реализации логических операций.
Диаграмма пакетов может использоваться для разбиения системы на модули, но компонент может быть более широким понятием, чем модуль.
Агрегация - это процесс, который может быть визуализирован с помощью пакетов.
Агрегаты могут пересекаться, и для их визуализации можно использовать прямоугольники над диаграммой.

12. Примеры архитектуры
Архитектура Git
Git - это одна из первых распределенных систем контроля версий, разработанная Линусом Торвальдсом.
Git хранит всю информацию в локальном репозитории, который организован как открытая папка Git, сидящая рядом с исходниками.
Git использует рефы для реализации веток и тэгов, а также для хранения информации о текущем содержимом рабочей копии.
Git также имеет набор скриптов, которые могут выполняться при выполнении действий с репозиторием, и конфиг, который содержит Git.
В режиме хранения объектов, которые являются содержимыми файлами, они предназначены для эффективного хранения, но не более.
Git использует хэширование для хранения информации о файлах, что позволяет быстро находить нужный файл в файловой системе.
Комиты могут иметь родителей, и список комитов Позволяет выстроить историю изменений.
Рефы - это не объект, а просто имена для хэшей.
Рефы могут ссылаться на комиты или что-то еще, и они могут быть изменены вручную.
Рефлок — структура данных, которая запоминает все действия с веткой.
Метки — ссылки на коммиты, позволяющие переключаться между ветками.
Пакеты файлов используются для сжатия файлов и хранения их в одном большом файле.
Крифлок — структура данных, которая отслеживает изменения в ветках.
В качестве противоположности Git считает Mercurial, который решает те же задачи, но с другим подходом.
Mercurial развивался медленнее, но с большим вниманием к деталям и архитектуре.
Он был написан на Python и изначально задумывался как расширяемая система, которую каждый пользователь может дописывать и настраивать под свои нужды.•Основа структуры данных Mercurial - ревок, который хранит всю информацию о хранимых данных.
Каждый файл хранится в виде ревизий, которые хранятся в виде дельта.
Ревизии регистрируются с помощью записей в ревлоге, которые также используют дельта-компрессию для эффективного хранения информации.
Релоги учитывают иерархическую структуру, где есть чейндж-лок — общий для всей репозитории, манифест — хранит информацию о файлах и ссылках в логах, а также директорию — информацию о рабочих копиях и кэш-дерево файла.
Ревоги обновляются в постепенном порядке, начиная с лога файла и далее, что позволяет избежать проблем с питанием.
Ревлогии — полноценные объекты в репозитории, которые также используют дельта-компрессию для хранения только измененных файлов.
В ревизии Mercurial есть голосовой номер, который позволяет быстро найти нужную ревизию.
Локальные обзоры имеют хэш, который используется для операций с удаленными обзорами.
Ветви в Mercurial реализованы через именованные ветки, которые хранятся в ревлогах. Последний комит в каждой ветке называется типом, и есть последний по времени комит, который считается типом последней ветки.
В Mercurial есть возможность создавать анонимные ветки, которые можно легко удалить или забыть.
Для удобства использования анонимных веток есть букмарки, которые работают как git-теги. Теги хранятся как файлы в репозиториях Mercurial.
В Mercurial есть расширения механизмов, такие как возможность добавлять новые команды, переопределять опции команды, переиспользовать опции в разных командах, а также возможность писать обертки для существующей команды.
Возможность подсунуть свои репозитории позволяет использовать локальную разработку с помощью меркурийских команд над репозиторием свершины.
Механизмы лясов позволяют переопределять название команды с параметрами, а механизмы фуков могут быть реализованы на Python или Shell.

13. Проектирование распределенных приложений, часть первая: технические вопросы
В современном мире большинство приложений являются распределенными, использующими внешние сервисы и развернутыми в облаке.
Распределенные системы состоят из независимых компонентов, работающих в разных процессах и машинах, взаимодействующих через обмен сообщениями.
Они предназначены для работы с общими ресурсами, большими объемами данных или вычислений.
RPC-системы работают по принципу "вызов-ответ", где клиентская программа формирует запрос, который отправляется клиентской заглушке, а серверная заглушка дергает процедуру, реализованную программистом.
Удаленные вызовы могут быть успешными или неудачными, и их обработка может быть сложной.
Отказы сети могут привести к повторным попыткам доставки сообщений.
Важно различать временные и постоянные отказы, и учитывать семантику запросов и обработки ошибок.
Protobuf- бинарный формат реализации, используемый для передачи данных между угловыми сервисами. Он обеспечивает компактность и обратную совместимость, позволяя серверам и клиентам работать с разными версиями сервиса.
gRPC - классическая реализация схемы удаленного вызова, использующая протобав для передачи данных и обработки исключений.
gRPC - это механизм для создания легковесных сервисов, которые не должны торчать наружу.
Веб-сервисы предоставляют удаленные вызовы и метаинформацию, что позволяет им работать без описания.
Веб-сервисы проектируются как набор веб-сервисов, которые взаимодействуют друг с другом.
Веб-сервисы используют протокол HTTP для передачи данных, но не всегда поддерживают сложные механизмы взаимодействия, такие как распределенные транзакции.
Веб-сервисы могут быть реализованы на разных языках, включая Java, C#, и C++.
Веб-сервисы используют протокол SOAP для передачи данных, но он может быть многословным и не всегда подходит для открытых сервисов.
Веб-сервисы могут быть реализованы с использованием стандарта WSDL, который позволяет генерировать клиентские заглушки без необходимости иметь априорные знания о сервисе.
Веб-сервисы изначально проектировались как связующий механизм для интернет-сервисов, но идея не прижилась из-за сложности интеграции со сторонним кодом и возможности третьей стороны диктовать свои условия.
Фреймворк DotNet WCF - это конфигурируемый фреймворк для реализации сетевых взаимодействий, который позволяет создавать энд-пойнты, бандинги, контракты и заглушки.
Код сервиса для работы с со сервисами состоит из описания контракта, реализации сервиса и настройки энд-пойнта.
• Клиентская сторона со сервисов состоит из заглушки, которая генерируется автоматически или вручную, и конфигурационного файла, который содержит адрес энд-пойнта сервера и другие параметры.
Обработка ошибок в со сервисах обычно осуществляется через исключения, которые могут быть плохо документированы. В нормальных системах стратегия обработки ошибок должна быть индивидуальной для каждого приложения.
Рест (REST) - разумная альтернатива SOAP, которая сейчас более популярна.
Рест декларирует, что данные не хранятся на сервере, а таскаются запросом.
Это позволяет выполнять разные запросы с одного клиента и не запоминать состояние сессии
Модель данных в рест-сервисах - коллекция и элементы.
Для выполнения операций используются стандартные методы GET, POST, PUT, DELETE.
Пример реализации рест-сервиса - Google Drive.
